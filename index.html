<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Crystal of Atlan - Live Event Countdown Timers (All Times UTC)</title>
  <style>
    body { background: #232a34; color: #fff; font-family: Arial, sans-serif; margin: 0; min-height: 100vh; }
    h1 { text-align: center; margin-top: 36px; margin-bottom: 32px; font-size: 2.2em; font-weight: 700; }
    .events-grid { display: flex; flex-wrap: wrap; max-width: 1500px; margin: auto; gap: 32px; justify-content: center; }
    .event-card { background: #262f3b; border-radius: 20px; box-shadow: 0 3px 12px #0006; padding: 30px 24px 26px 24px; min-width: 340px; max-width: 380px; text-align: center; margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; }
    .event-title { font-weight: bold; font-size: 1.25em; margin-bottom: 8px; }
    .event-desc { color: #b2bed6; margin-bottom: 18px; font-size: 1em; }
    .timer { font-size: 1.5em; font-family: 'Consolas', monospace; color: #ffe066; margin-bottom: 3px; letter-spacing: 1px; }
    .event-time { font-size: 1em; color: #a8e1f7; margin-bottom: 2px; }
    .event-schedule { font-size: 0.97em; color: #eee; margin-bottom: 3px; }
    .event-duration { font-size: 0.97em; color: #90ee90; margin-bottom: 8px; }
    .active { color: #90ee90; }
    .inactive { color: #ffe066; }
    @media (max-width: 1100px) { .events-grid { flex-direction: column; align-items: center; } .event-card { min-width: 250px; max-width: 90vw; } }
  </style>
</head>
<body>
  <h1>Crystal of Atlan - Live Event Countdown Timers (All Times UTC)</h1>
  <div class="events-grid" id="events"></div>
  <script>
    function pad(n){return n.toString().padStart(2,'0');}
    function getDurationText(hours, minutes) {
      let result = [];
      if (hours > 0) result.push(hours + "h");
      if (minutes > 0) result.push(minutes + "m");
      return result.length ? result.join(" ") : "Instant";
    }

    // All times are in UTC
    const events = [
      {
        id: 'ancient_battlefield_1',
        summary: 'Ancient Battlefield 1',
        desc: 'Matchmaking available daily',
        startHour: 16, startMinute: 30,
        endHour: 18, endMinute: 0,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 1, minutes: 30 }
      },
      {
        id: 'ancient_battlefield_2',
        summary: 'Ancient Battlefield 2',
        desc: 'Matchmaking available daily',
        startHour: 0, startMinute: 0,
        endHour: 2, endMinute: 0,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 2, minutes: 0 }
      },
      {
        id: 'mine_wars_1',
        summary: 'Mine Wars 1',
        desc: 'Opens daily',
        startHour: 16, startMinute: 0,
        endHour: 18, endMinute: 0,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 2, minutes: 0 }
      },
      {
        id: 'mine_wars_2',
        summary: 'Mine Wars 2',
        desc: 'Opens daily',
        startHour: 1, startMinute: 0,
        endHour: 3, endMinute: 0,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 2, minutes: 0 }
      },
      {
        id: 'spirit_frenzy_weekday',
        summary: 'Spirit Frenzy (Weekday)',
        desc: 'Opens Mon-Fri',
        startHour: 0, startMinute: 0,
        endHour: 0, endMinute: 15,
        days: [1,2,3,4,5],
        duration: { hours: 0, minutes: 15 }
      },
      {
        id: 'spirit_frenzy_weekend',
        summary: 'Spirit Frenzy (Weekend)',
        desc: 'Opens Sat & Sun',
        startHour: 0, startMinute: 0,
        endHour: 0, endMinute: 15,
        days: [0,6],
        duration: { hours: 0, minutes: 15 }
      },
      {
        id: 'joint_siege_friday',
        summary: 'Joint Siege (Friday)',
        desc: 'Starts Friday',
        startHour: 0, startMinute: 30,
        endHour: 1, endMinute: 0,
        days: [5],
        duration: { hours: 0, minutes: 30 }
      },
      {
        id: 'joint_siege_sunday',
        summary: 'Joint Siege (Sunday)',
        desc: 'Starts Sunday',
        startHour: 0, startMinute: 30,
        endHour: 1, endMinute: 0,
        days: [0],
        duration: { hours: 0, minutes: 30 }
      },
      {
        id: 'arena_early',
        summary: 'Arena (Crystal Arena) Early',
        desc: 'Open daily',
        startHour: 4, startMinute: 0,
        endHour: 6, endMinute: 0,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 2, minutes: 0 }
      },
      {
        id: 'arena_late',
        summary: 'Arena (Crystal Arena) Late',
        desc: 'Open daily',
        startHour: 11, startMinute: 0,
        endHour: 14, endMinute: 0,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 3, minutes: 0 }
      },
      // --- NEW RESET EVENTS BELOW ---
      {
        id: 'arena_reset',
        summary: 'Arena Reset',
        desc: 'Every other Monday at 06:00 UTC',
        startHour: 6, startMinute: 0,
        endHour: 6, endMinute: 1,
        duration: { hours: 0, minutes: 1 },
        // Every other Monday: week number is even
        customNext: function(nowUTC) {
          // Find next Monday at 06:00 UTC that is an even ISO week
          function getISOWeek(date) {
            const tmp = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
            const dayNum = tmp.getUTCDay() || 7;
            tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(),0,1));
            return Math.ceil((((tmp - yearStart)/86400000) + 1)/7);
          }
          let d = new Date(nowUTC);
          d.setUTCSeconds(0,0);
          let day = d.getUTCDay();
          let daysUntilMonday = (1 - day + 7) % 7;
          let nextMonday = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + daysUntilMonday, 6, 0, 0, 0));
          // If today is Monday and before 06:00, keep this Monday
          if (day === 1 && (d.getUTCHours() < 6)) {
            nextMonday = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 6, 0, 0, 0));
          }
          // If today is Monday and after 06:00, go to next Monday
          else if (day === 1 && (d.getUTCHours() >= 6)) {
            nextMonday = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + 7, 6, 0, 0, 0));
          }
          // Loop until we find an even ISO week
          while (getISOWeek(nextMonday) % 2 !== 0) {
            nextMonday.setUTCDate(nextMonday.getUTCDate() + 7);
          }
          let nextEnd = new Date(nextMonday.getTime() + 60000); // 1 min reset
          return {utcStart: nextMonday, utcEnd: nextEnd, isActive: (nowUTC >= nextMonday && nowUTC < nextEnd), localStart: nextMonday, localEnd: nextEnd};
        }
      },
      {
        id: 'hexchess_rewards_reset',
        summary: 'Hexchess Rewards Reset',
        desc: 'Every Monday at 06:00 UTC',
        startHour: 6, startMinute: 0,
        endHour: 6, endMinute: 1,
        days: [1],
        duration: { hours: 0, minutes: 1 }
      },
      {
        id: 'energy_replenishment_reset',
        summary: 'Energy Replenishment Daily Reset',
        desc: 'Resets daily at 06:00 UTC',
        startHour: 6, startMinute: 0,
        endHour: 6, endMinute: 1,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 0, minutes: 1 }
      },
      {
        id: 'tempered_trials_reset',
        summary: 'Tempered Trials Daily Reset',
        desc: 'Resets daily at 06:00 UTC',
        startHour: 6, startMinute: 0,
        endHour: 6, endMinute: 1,
        days: [0,1,2,3,4,5,6],
        duration: { hours: 0, minutes: 1 }
      }
    ];

    function getNextEventTimes(event, nowUTC) {
      if (event.customNext) {
        return event.customNext(nowUTC);
      }
      let {startHour, startMinute, endHour, endMinute, days} = event;
      let localDay = nowUTC.getUTCDay();
      let localYear = nowUTC.getUTCFullYear();
      let localMonth = nowUTC.getUTCMonth();
      let localDate = nowUTC.getUTCDate();

      let eventDays = days || [0,1,2,3,4,5,6];

      let nextStart = null, nextEnd = null;
      for (let i = 0; i <= 7; ++i) {
        let d = (localDay + i) % 7;
        if (eventDays.includes(d)) {
          let candidateStart = new Date(Date.UTC(localYear, localMonth, localDate + i, startHour, startMinute, 0, 0));
          if (i === 0 && (nowUTC.getUTCHours() > startHour || (nowUTC.getUTCHours() === startHour && nowUTC.getUTCMinutes() >= startMinute))) continue;
          nextStart = candidateStart;
          nextEnd = new Date(Date.UTC(localYear, localMonth, localDate + i, endHour, endMinute, 0, 0));
          // If event ends on or before it starts, it's next day!
          if (
            endHour < startHour ||
            (endHour === startHour && endMinute <= startMinute)
          ) {
            nextEnd.setUTCDate(nextEnd.getUTCDate() + 1);
          }
          break;
        }
      }
      let currentStart = new Date(Date.UTC(localYear, localMonth, localDate, startHour, startMinute, 0, 0));
      let currentEnd = new Date(Date.UTC(localYear, localMonth, localDate, endHour, endMinute, 0, 0));
      // If event ends on or before it starts, it's next day!
      if (
        endHour < startHour ||
        (endHour === startHour && endMinute <= startMinute)
      ) {
        currentEnd.setUTCDate(currentEnd.getUTCDate() + 1);
      }
      let isActive = eventDays.includes(localDay) &&
        nowUTC >= currentStart && nowUTC < currentEnd;
      if (isActive) {
        nextStart = currentStart;
        nextEnd = currentEnd;
      }
      return {utcStart: nextStart, utcEnd: nextEnd, isActive, localStart: nextStart, localEnd: nextEnd};
    }

    function renderEvents() {
      const container = document.getElementById('events');
      container.innerHTML = '';
      events.forEach(event => {
        const card = document.createElement('div');
        card.className = 'event-card';
        card.innerHTML = `
          <div class="event-title">${event.summary}</div>
          <div class="event-desc">${event.desc}</div>
          <div class="event-duration" id="duration-${event.id}"></div>
          <div class="event-schedule" id="schedule-${event.id}"></div>
          <div class="timer" id="timer-${event.id}"></div>
          <div class="event-time" id="time-${event.id}"></div>
        `;
        container.appendChild(card);
      });
    }

    function updateTimers() {
      const now = new Date();
      events.forEach(event => {
        const {utcStart, utcEnd, isActive, localStart, localEnd} = getNextEventTimes(event, now);
        const el = document.getElementById('timer-' + event.id);
        const tm = document.getElementById('time-' + event.id);
        const sch = document.getElementById('schedule-' + event.id);
        const dur = document.getElementById('duration-' + event.id);

        function fmt(dt) {
          return pad(dt.getUTCHours()) + ":" + pad(dt.getUTCMinutes());
        }
        sch.innerHTML =
          `<b>Start:</b> ${fmt(localStart)} &nbsp; <b>End:</b> ${fmt(localEnd)} UTC`;

        dur.textContent = `Duration: ${getDurationText(event.duration.hours, event.duration.minutes)}`;

        if (isActive) {
          let diff = Math.floor((utcEnd - now) / 1000);
          const d = Math.floor(diff / 86400);
          const h = Math.floor((diff % 86400) / 3600);
          const m = Math.floor((diff % 3600) / 60);
          const s = diff % 60;
          el.innerHTML = `<span class="active">Event Active! Ends in: ${d}d ${pad(h)}h ${pad(m)}m ${pad(s)}s</span>`;
          tm.textContent = `(Ends at: ${fmt(localEnd)} UTC)`;
        } else {
          let diff = Math.floor((utcStart - now) / 1000);
          if (diff < 0) diff = 0;
          const d = Math.floor(diff / 86400);
          const h = Math.floor((diff % 86400) / 3600);
          const m = Math.floor((diff % 3600) / 60);
          const s = diff % 60;
          el.innerHTML = `<span class="inactive">Starts in: ${d}d ${pad(h)}h ${pad(m)}m ${pad(s)}s</span>`;
          tm.textContent = `(Starts at: ${fmt(localStart)} UTC)`;
        }
      });
    }

    renderEvents();
    updateTimers();
    setInterval(updateTimers, 1000);
  </script>
</body>
</html>
